#include "parser.h"
#include "util.h"
#include <stdio.h>
#include <stdlib.h>

#define ASM(x)												\
	strcat_s(Parser.asmFile, INITIAL_SOURCE_CODE_SIZE + 1,	\
		x													\
	);														\
	strcat_s(Parser.immFile, INITIAL_SOURCE_CODE_SIZE + 1,	\
		"\n"												\
	);

#define ASMI(x)												\
	strcat_s(Parser.asmFile, INITIAL_SOURCE_CODE_SIZE + 1,	\
		x													\
	);	

#define IMM(x)												\
	strcat_s(Parser.immFile, INITIAL_SOURCE_CODE_SIZE + 1,	\
		x													\
	);

extern Parser_t Parser;

void ParserInit(char* asmFile, char* immFile) {
	Parser.Tokens = malloc(sizeof(Token_t));
	if (!Parser.Tokens) {
		MALLOC_ERROR
	}

	Parser.asmFile = asmFile, Parser.immFile = immFile;

	//Parser.asmFile[INITIAL_SOURCE_CODE_SIZE + 1] = '\0';
	//Parser.immFile[INITIAL_SOURCE_CODE_SIZE + 1] = '\0';
	Parser.asmFile[1] = '\0';
	Parser.immFile[1] = '\0';
}

int ParserParse() {
	//strcat_s(Parser.asmFile, INITIAL_SOURCE_CODE_SIZE + 1, " ; Generated by g3050 comp\n"); // little watermark
	//strcat_s(Parser.immFile, INITIAL_SOURCE_CODE_SIZE + 1, " ; Generated by g3050 comp\n");

	Token_t* next = Parser.Tokens;
	char* loopStartPos = NULL;
	while (1) {
		if (!next)
			break;
		printf("%c", next->Token);

		/*
			Register Table
			R1 - Cell Pointer
			R2 - Cell Math Accumulator & TTY char && User input
			R3 - TTY text loc
		*/
		switch (next->Token) {
			case '>':
				ASM("add 1 1 imm ; >\n")
				IMM("0 1 0 0\n");

				break;
			case '<':
				ASMI("add 1 1 imm ; <\n")
				IMM("0 1 0 0\n");

				break;
			case '+':
				ASM("load 2 1 0 ; +\n")
				ASMI("add 2 2 imm\n")
				IMM("0 1 0 0\n");
				ASM("store 2 1 0\n")

				break;
			case '-':
				ASM("load 2 1 0 ; -\n")
				ASMI("sub 2 2 imm\n")
				IMM("0 1 0 0\n");
				ASM("store 2 1 0\n")

				break;
			case '[':
				loopStartPos = encode_packed_imms(getCurrentLine(Parser.asmFile), 0, true);

				break;
			case ']':
				ASM("load 2 1 0 ; ]\n")
				ASMI("beq imm 1 0\n");
				IMM(loopStartPos);

				free(loopStartPos);
				loopStartPos = NULL;
				break;
			case ',':
				break;
			case '.':
				ASMI("add 3 3 imm ; .\n")
				IMM("0 1 0 0\n");
				ASM("load 2 1 0\n")
				ASM("out 0 3 0\n") // Output TTY loc
				ASMI("out 0 2 imm\n") // Output TTY char
				IMM("0 2 0 0\n")
				ASMI("out 0 0 imm\n")
				IMM("0 3 0 0\n")
				break;
		}

		next = next->next;
	}
	
	return 0;
}

void ParserPush(const char newToken) {
	Token_t* _newToken = realloc(Parser.Tokens, Parser.tokensSizeBytes + sizeof(Token_t));
	if (!_newToken) {
		REALLOC_ERROR
	}

	for (int i = 0; i < Parser.tokensSize; i++)
		_newToken[i].next = &_newToken[i + 1].Token;

	Parser.tokensSize++, Parser.tokensSizeBytes += sizeof(Token_t);

	_newToken[Parser.tokensSize - 1].Token = newToken;

	if (newToken != '\0')
		_newToken[Parser.tokensSize - 1].next = &_newToken[Parser.tokensSize].Token;
	else
		_newToken[Parser.tokensSize - 1].next = NULL;

	Parser.Tokens = _newToken;
}
